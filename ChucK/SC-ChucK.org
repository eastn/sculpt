#+BEGIN_EXAMPLE
Using ChucK as sound server from SuperCollider
                         or:
Using SuperCollider as language environment for ChucK.
#+END_EXAMPLE

Started: [2014-06-03 Tue]

* First steps
:PROPERTIES:
:DATE:     <2014-06-05 Thu 09:43>
:END:

Some code to test OSC communication between ChucK & SuperCollider. Downloaded from: http://www.ixi-software.net/workshops/files.php

* SuperCollider meets WaveGuide (ChucK)

ModalBar is a ugen part of WaveGuide synthesis in ChucK which will be used as the synthesis engine of the Sculpt.
This is the first experiment using ChucK and WaveGuide, it includes two files a chuck and a SuperCollider document that implements an OSC communication between the former and the later. SuperCollider controls the parameters of the ModalBar. You may find these two docs within the ChucK folder of the Sculpt repository, as usual.
=======
* Patterns
:PROPERTIES:
:DATE:     <2014-06-05 Thu 09:44>
:END:

Define a new event type, initially called =\chuckTest= that plays like this:

#+BEGIN_EXAMPLE
NetAddr("127.0.0.1", 6449)
.sendMsg(
    <symbol: instrument_name>,
    <integer: preset>,
    <float: freq>, // following parameters depend on instrument
                   // example here is from ModalBar
    <float: par1>, // stick hardness
    <float: par2>, // strike position
    <float: par3>, // vibrato gain
    <float: par4>, // vibrato freq
    <float: par5>, // vol (no effect)
    <float: par6>, // direct gain
    <float: par7>  // master gain
);
#+END_EXAMPLE

See SC Help, Class =Event=, class method =addEventType=.

: *addEventType(type, func)

The new event type should be based on the default =note= event type, which is currently found in lines 476 to 557 of =Event.sc=.  The reason is that in this way it can use all of the note's musical parameter infrastructure (octave, scale, degree, note, midinote etc).  Unfortunately, this function is (a) complex (b) difficult to modify (not modular). Simple, fictitious template to orient the coding:

#+BEGIN_EXAMPLE
{
NetAddr("127.0.0.1", 6449).sendMsg(
   ~instrument,
   ~preset ? 0,
   ~freq, // need to find how to eval ~freq to get the final value
   ~hardness ? 0.5,
   ~strikePos ? 0.5,
   ~vibrGain ? 0.1,
   ~vibrFreq ? 5,
   ~vol ? 1,
   ~directGain ? 0.5,
   ~masterGain ? 0.5
)
}
#+END_EXAMPLE

Test this eventType with:

: Pbind(\type, \chuckTest, degree: 0).play;

Possibly, =~freq= can be got like this:

#+BEGIN_EXAMPLE
var freqs, lag, /* strum, */ server;
var msgFunc, instrumentName, bndl;

freqs = ~detunedFreq.value;
if (freqs.isRest.not) {
// msgFunc gets the synth's control values from the Event
msgFunc = ~getMsgFunc.valueEnvir;
instrumentName = ~synthDefName.valueEnvir;
// update values in the Event that may be determined by functions
~freq = freqs;
~amp = ~amp.value;
offset = ~timingOffset;
// strum = ~strum;
~server = server;
~isPlaying = true;
// compute the control values and generate OSC commands
bndl = msgFunc.valueEnvir;
bndl = [instrumentName] ++ bndl;
#+END_EXAMPLE

Next steps: Find out and test how =msgFunc= works, write your own version for =getMsgFunc=.
