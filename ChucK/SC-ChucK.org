#+BEGIN_EXAMPLE
Using ChucK as sound server from SuperCollider
                         or:
Using SuperCollider as language environment for ChucK.
#+END_EXAMPLE

Started: [2014-06-03 Tue]

* First steps
:PROPERTIES:
:DATE:     <2014-06-05 Thu 09:43>
:END:

Some code to test OSC communication between ChucK & SuperCollider. Downloaded from: http://www.ixi-software.net/workshops/files.php

* Patterns
:PROPERTIES:
:DATE:     <2014-06-05 Thu 09:44>
:END:

** DONE Chuck event type for patterns
CLOSED: [2014-06-10 Tue 18:26]
:PROPERTIES:
:DATE:     <2014-06-10 Tue 18:26>
:END:
Define a new event type, initially called =\chuckTest= that plays like this:

#+BEGIN_EXAMPLE
NetAddr("127.0.0.1", 6449)
.sendMsg(
    <symbol: instrument_name>,
    <integer: preset>,
    <float: freq>, // following parameters depend on instrument
                   // example here is from ModalBar
    <float: par1>, // stick hardness
    <float: par2>, // strike position
    <float: par3>, // vibrato gain
    <float: par4>, // vibrato freq
    <float: par5>, // vol (no effect)
    <float: par6>, // direct gain
    <float: par7>  // master gain
);
#+END_EXAMPLE

See SC Help, Class =Event=, class method =addEventType=.

: *addEventType(type, func)

The new event type should be based on the default =note= event type, which is currently found in lines 476 to 557 of =Event.sc=.  The reason is that in this way it can use all of the note's musical parameter infrastructure (octave, scale, degree, note, midinote etc).  Unfortunately, this function is (a) complex (b) difficult to modify (not modular). Simple, fictitious template to orient the coding:

#+BEGIN_EXAMPLE
{
NetAddr("127.0.0.1", 6449).sendMsg(
   ~instrument,
   ~preset ? 0,
   ~freq, // need to find how to eval ~freq to get the final value
   ~hardness ? 0.5,
   ~strikePos ? 0.5,
   ~vibrGain ? 0.1,
   ~vibrFreq ? 5,
   ~vol ? 1,
   ~directGain ? 0.5,
   ~masterGain ? 0.5
)
}
#+END_EXAMPLE

Test this eventType with:

: Pbind(\type, \chuckTest, degree: 0).play;

Possibly, =~freq= can be got like this:

#+BEGIN_EXAMPLE
var freqs, lag, /* strum, */ server;
var msgFunc, instrumentName, bndl;

freqs = ~detunedFreq.value;
if (freqs.isRest.not) {
// msgFunc gets the synth's control values from the Event
msgFunc = ~getMsgFunc.valueEnvir;
instrumentName = ~synthDefName.valueEnvir;
// update values in the Event that may be determined by functions
~freq = freqs;
~amp = ~amp.value;
offset = ~timingOffset;
// strum = ~strum;
~server = server;
~isPlaying = true;
// compute the control values and generate OSC commands
bndl = msgFunc.valueEnvir;
bndl = [instrumentName] ++ bndl;
#+END_EXAMPLE

Next steps: Find out and test how =msgFunc= works, write your own version for =getMsgFunc=.

** STARTED Send event type params Chuck->SC
:PROPERTIES:
:DATE:     <2014-06-10 Tue 18:27>
:END:

Write the event type parameter specifications in ChucK and send them over to SuperCollider.  Have SuperCollider create a new event type from the specs received from ChucK.  Thus it is not necessary to code a new event type in SuperCollider, but only in ChucK.
